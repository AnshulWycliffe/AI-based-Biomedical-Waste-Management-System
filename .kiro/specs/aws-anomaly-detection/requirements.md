# Requirements Document: AWS Anomaly Detection

## Introduction

This document specifies requirements for an AWS-based anomaly detection system integrated into the CivicBio biomedical waste management application. The system detects unusual waste generation patterns using serverless architecture (AWS Lambda) and provides civic authorities with real-time insights into potentially problematic facilities.

The system operates within an existing Flask application using MongoDB (MongoEngine) for data persistence, boto3 for AWS integration, and follows the Asia/Kolkata (IST) timezone convention.

## Glossary

- **Anomaly_Detector**: AWS Lambda function that performs statistical analysis on waste quantities
- **Waste_Entry**: A record of biomedical waste generated by a facility
- **Facility**: A healthcare or biomedical institution that generates waste (user with role="facility")
- **Civic_User**: Municipal authority user who monitors waste management compliance
- **Z_Score**: Statistical measure of how many standard deviations a value is from the mean
- **Anomaly_Threshold**: The Z-score absolute value (2.5) beyond which a waste quantity is flagged
- **Historical_Window**: The 30-day period used for calculating statistical baselines
- **WasteAnomaly_Record**: MongoDB document storing detected anomaly information
- **CloudWatch**: AWS logging service for audit trails
- **Flask_Application**: The CivicBio web application backend
- **Boto3_Client**: AWS SDK for Python used to invoke Lambda functions

## Requirements

### Requirement 1: Statistical Anomaly Detection

**User Story:** As a civic authority, I want the system to automatically detect unusual waste generation patterns, so that I can identify facilities that may require investigation or intervention.

#### Acceptance Criteria

1. WHEN the Anomaly_Detector receives a facility_id, current_quantity, and historical_quantities, THE Anomaly_Detector SHALL calculate the mean of historical_quantities
2. WHEN the Anomaly_Detector receives a facility_id, current_quantity, and historical_quantities, THE Anomaly_Detector SHALL calculate the standard deviation of historical_quantities
3. WHEN the Anomaly_Detector has calculated mean and standard deviation, THE Anomaly_Detector SHALL compute the Z-score as (current_quantity - mean) / std_dev
4. WHEN the absolute value of the Z-score is greater than or equal to 2.5, THE Anomaly_Detector SHALL flag the waste entry as an anomaly
5. WHEN the absolute value of the Z-score is less than 2.5, THE Anomaly_Detector SHALL flag the waste entry as not an anomaly
6. WHEN the Anomaly_Detector completes analysis, THE Anomaly_Detector SHALL return is_anomaly, z_score, mean, and std_dev values

### Requirement 2: Edge Case Handling

**User Story:** As a system administrator, I want the anomaly detector to handle edge cases gracefully, so that the system remains reliable with incomplete or unusual data.

#### Acceptance Criteria

1. IF the standard deviation of historical_quantities equals zero, THEN THE Anomaly_Detector SHALL return is_anomaly as false
2. IF the count of historical_quantities is less than 5, THEN THE Anomaly_Detector SHALL return is_anomaly as false
3. WHEN the Anomaly_Detector encounters invalid input data, THE Anomaly_Detector SHALL return an error response with descriptive message
4. WHEN historical_quantities contains non-numeric values, THE Anomaly_Detector SHALL filter them out before calculation

### Requirement 3: AWS Lambda Implementation

**User Story:** As a developer, I want the anomaly detection logic implemented as an AWS Lambda function, so that the system scales automatically and minimizes infrastructure costs.

#### Acceptance Criteria

1. THE Anomaly_Detector SHALL be implemented as an AWS Lambda function using Python runtime
2. THE Anomaly_Detector SHALL use only the Python standard library statistics module for calculations
3. THE Anomaly_Detector SHALL NOT use heavy machine learning frameworks or external dependencies
4. WHEN the Anomaly_Detector is invoked, THE Anomaly_Detector SHALL complete execution within 3 seconds
5. THE Anomaly_Detector SHALL accept input as JSON with fields: facility_id, current_quantity, historical_quantities
6. THE Anomaly_Detector SHALL return output as JSON with fields: is_anomaly, z_score, mean, std_dev, facility_id

### Requirement 4: CloudWatch Audit Logging

**User Story:** As a compliance officer, I want all anomaly detection events logged to CloudWatch, so that I can audit the system's decisions and maintain regulatory compliance.

#### Acceptance Criteria

1. WHEN the Anomaly_Detector completes an analysis, THE Anomaly_Detector SHALL log the facility_id to CloudWatch
2. WHEN the Anomaly_Detector completes an analysis, THE Anomaly_Detector SHALL log the current_quantity to CloudWatch
3. WHEN the Anomaly_Detector completes an analysis, THE Anomaly_Detector SHALL log the z_score to CloudWatch
4. WHEN the Anomaly_Detector completes an analysis, THE Anomaly_Detector SHALL log the anomaly_detected boolean to CloudWatch
5. WHEN the Anomaly_Detector completes an analysis, THE Anomaly_Detector SHALL log the timestamp in ISO 8601 format to CloudWatch

### Requirement 5: Flask Application Integration

**User Story:** As a facility user, I want waste entry creation to remain fast and reliable, so that anomaly detection does not disrupt my normal workflow.

#### Acceptance Criteria

1. WHEN a Facility creates a Waste_Entry, THE Flask_Application SHALL save the Waste_Entry to MongoDB before invoking anomaly detection
2. WHEN a Waste_Entry is saved, THE Flask_Application SHALL query the last 30 days of waste quantities for that facility_id
3. WHEN historical quantities are retrieved, THE Flask_Application SHALL invoke the Anomaly_Detector via Boto3_Client with facility_id, current_quantity, and historical_quantities
4. WHEN the Anomaly_Detector returns a response, THE Flask_Application SHALL parse the JSON response
5. IF the response indicates is_anomaly is true, THEN THE Flask_Application SHALL create a WasteAnomaly_Record in MongoDB
6. IF the Boto3_Client invocation fails or times out, THEN THE Flask_Application SHALL log the error and continue without blocking waste creation
7. WHEN the Flask_Application invokes the Anomaly_Detector, THE Flask_Application SHALL set a timeout of 5 seconds

### Requirement 6: MongoDB Data Model

**User Story:** As a developer, I want anomaly data stored in a structured format, so that civic users can query and analyze historical anomalies.

#### Acceptance Criteria

1. THE WasteAnomaly_Record SHALL contain a facility_id field referencing the Facility
2. THE WasteAnomaly_Record SHALL contain a waste_id field referencing the Waste_Entry
3. THE WasteAnomaly_Record SHALL contain an actual_quantity field storing the anomalous quantity value
4. THE WasteAnomaly_Record SHALL contain a mean field storing the calculated historical mean
5. THE WasteAnomaly_Record SHALL contain a std_dev field storing the calculated standard deviation
6. THE WasteAnomaly_Record SHALL contain a z_score field storing the calculated Z-score
7. THE WasteAnomaly_Record SHALL contain a flagged field with default value true
8. THE WasteAnomaly_Record SHALL contain a created_at field storing the timestamp in Asia/Kolkata timezone

### Requirement 7: Civic Dashboard Integration

**User Story:** As a civic authority, I want to see anomaly statistics and recent alerts on my dashboard, so that I can quickly identify facilities requiring attention.

#### Acceptance Criteria

1. WHEN a Civic_User views the dashboard, THE Flask_Application SHALL display a KPI showing the count of anomalies detected today
2. WHEN calculating today's anomalies, THE Flask_Application SHALL use the Asia/Kolkata timezone to determine the current date
3. WHEN a Civic_User views the dashboard, THE Flask_Application SHALL display a list of the 10 most recent WasteAnomaly_Records
4. WHEN displaying anomaly records, THE Flask_Application SHALL show facility_id, actual_quantity, z_score, and created_at for each record
5. WHEN displaying anomaly records, THE Flask_Application SHALL highlight facilities with multiple anomalies in the last 7 days
6. WHEN a Civic_User clicks on an anomaly record, THE Flask_Application SHALL navigate to detailed facility information

### Requirement 8: Error Handling and Resilience

**User Story:** As a system administrator, I want the system to handle AWS service failures gracefully, so that core waste management functionality remains available during outages.

#### Acceptance Criteria

1. IF the Boto3_Client cannot connect to AWS Lambda, THEN THE Flask_Application SHALL log the connection error and continue processing
2. IF the Anomaly_Detector returns a malformed response, THEN THE Flask_Application SHALL log the parsing error and continue processing
3. IF the Anomaly_Detector returns an error status code, THEN THE Flask_Application SHALL log the error details and continue processing
4. WHEN AWS service errors occur, THE Flask_Application SHALL NOT prevent Waste_Entry creation
5. WHEN AWS service errors occur, THE Flask_Application SHALL return a success response to the Facility user

### Requirement 9: Historical Data Retrieval

**User Story:** As a developer, I want efficient retrieval of historical waste data, so that anomaly detection performs quickly without database bottlenecks.

#### Acceptance Criteria

1. WHEN retrieving historical quantities, THE Flask_Application SHALL query Waste_Entry records for the specific facility_id
2. WHEN retrieving historical quantities, THE Flask_Application SHALL filter for records created within the last 30 days
3. WHEN retrieving historical quantities, THE Flask_Application SHALL extract only the quantity field from matching records
4. WHEN retrieving historical quantities, THE Flask_Application SHALL sort records by created_at in descending order
5. WHEN no historical records exist for a facility, THE Flask_Application SHALL pass an empty list to the Anomaly_Detector

### Requirement 10: S3 Report Storage (Optional)

**User Story:** As a civic authority, I want anomaly reports stored in S3 for long-term archival, so that I can access historical analysis data beyond the database retention period.

#### Acceptance Criteria

1. WHERE S3 integration is enabled, WHEN an anomaly is detected, THE Flask_Application SHALL generate a JSON report containing anomaly details
2. WHERE S3 integration is enabled, WHEN a report is generated, THE Flask_Application SHALL upload the report to a designated S3 bucket
3. WHERE S3 integration is enabled, WHEN a report is uploaded, THE Flask_Application SHALL store the S3 object key in the WasteAnomaly_Record
4. WHERE S3 integration is enabled, WHEN a Civic_User views an anomaly, THE Flask_Application SHALL provide a download link to the S3 report
5. WHERE S3 integration is enabled, IF S3 upload fails, THEN THE Flask_Application SHALL log the error without blocking anomaly record creation

### Requirement 11: Role-Based Access Control

**User Story:** As a system administrator, I want anomaly data accessible only to authorized civic users, so that facility privacy is maintained while enabling oversight.

#### Acceptance Criteria

1. WHEN a user requests anomaly dashboard data, THE Flask_Application SHALL verify the user has role equal to "civic"
2. IF a user does not have role equal to "civic", THEN THE Flask_Application SHALL return an authorization error
3. WHEN a Facility user views their own waste entries, THE Flask_Application SHALL NOT display anomaly flags or Z-scores
4. WHEN a Civic_User queries anomaly data, THE Flask_Application SHALL return all anomalies across all facilities

### Requirement 12: Timezone Consistency

**User Story:** As a civic authority in India, I want all timestamps displayed in IST, so that I can correlate anomalies with local events and schedules.

#### Acceptance Criteria

1. WHEN storing a WasteAnomaly_Record, THE Flask_Application SHALL set created_at to the current time in Asia/Kolkata timezone
2. WHEN displaying anomaly timestamps to users, THE Flask_Application SHALL format them in Asia/Kolkata timezone
3. WHEN calculating "today's anomalies", THE Flask_Application SHALL use Asia/Kolkata timezone to determine date boundaries
4. WHEN querying historical data for the last 30 days, THE Flask_Application SHALL calculate the date range using Asia/Kolkata timezone
